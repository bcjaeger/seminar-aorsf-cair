{
  "hash": "37d361cfe5fd7a159905db0a63fac30c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Oblique Random Forests\"\nsubtitle: \"Making Leo Breiman’s Masterpiece Accessible and Interpretable \"\nauthor: \"Byron C Jaeger\"\ndate: \"February 19, 2025\"\nformat: \n  revealjs:\n    theme: simple\n    slide-number: true\nexecute: \n  freeze: auto\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Hello, my name is Byron\n\n![](img/run_R_kids.png){fig-align=\"center\"}\n\n## Bottom line up front\n\n1. Oblique random forests are generally good prediction models, and they are very good for *spectral* data.\n\n1. `aorsf` provides a unified, simple, and fast interface for oblique random forests.\n\n## Spectral data\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 215 × 103\n   x_001 x_002 x_003 x_004 x_005 x_006 x_007 x_008 x_009 x_010 x_011 x_012 x_013\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  2.62  2.62  2.62  2.62  2.62  2.62  2.62  2.62  2.63  2.63  2.63  2.63  2.64\n 2  2.83  2.84  2.84  2.85  2.85  2.86  2.86  2.87  2.87  2.88  2.88  2.89  2.90\n 3  2.58  2.58  2.59  2.59  2.59  2.59  2.59  2.60  2.60  2.60  2.60  2.61  2.61\n 4  2.82  2.82  2.83  2.83  2.83  2.83  2.83  2.84  2.84  2.84  2.84  2.85  2.85\n 5  2.79  2.79  2.79  2.79  2.80  2.80  2.80  2.80  2.81  2.81  2.81  2.82  2.82\n 6  3.01  3.02  3.02  3.03  3.03  3.04  3.04  3.05  3.06  3.06  3.07  3.08  3.09\n 7  2.99  2.99  3.00  3.01  3.01  3.02  3.02  3.03  3.04  3.04  3.05  3.06  3.07\n 8  2.53  2.53  2.53  2.53  2.53  2.53  2.53  2.53  2.54  2.54  2.54  2.54  2.54\n 9  3.27  3.28  3.29  3.29  3.30  3.31  3.31  3.32  3.33  3.33  3.34  3.35  3.36\n10  3.40  3.41  3.41  3.42  3.43  3.43  3.44  3.45  3.46  3.47  3.48  3.48  3.49\n# ℹ 205 more rows\n# ℹ 90 more variables: x_014 <dbl>, x_015 <dbl>, x_016 <dbl>, x_017 <dbl>,\n#   x_018 <dbl>, x_019 <dbl>, x_020 <dbl>, x_021 <dbl>, x_022 <dbl>,\n#   x_023 <dbl>, x_024 <dbl>, x_025 <dbl>, x_026 <dbl>, x_027 <dbl>,\n#   x_028 <dbl>, x_029 <dbl>, x_030 <dbl>, x_031 <dbl>, x_032 <dbl>,\n#   x_033 <dbl>, x_034 <dbl>, x_035 <dbl>, x_036 <dbl>, x_037 <dbl>,\n#   x_038 <dbl>, x_039 <dbl>, x_040 <dbl>, x_041 <dbl>, x_042 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(bonsai)\nlibrary(modeldata)\n\n# Load the dataset\ndata(meats)\n\n# Define models\naxis <- rand_forest(mode = \"regression\", engine = \"ranger\")\noblique <- rand_forest(mode = \"regression\", engine = \"aorsf\")\n\n# Define cross-validation folds\nset.seed(123)\nsplits <- vfold_cv(meats, v = 5)  # 5-fold CV\n\n# Define a recipe (optional, but recommended)\nmeats_recipe <- recipe(protein ~ ., data = meats) %>%\n  step_normalize(all_numeric_predictors()) \n\n# Create workflows\naxis_wf <- workflow() %>%\n  add_model(axis) %>%\n  add_recipe(meats_recipe)\n\noblique_wf <- workflow() %>%\n  add_model(oblique) %>%\n  add_recipe(meats_recipe)\n```\n:::\n\n\n\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Resample both models using fit_resamples()\nset.seed(123)\n\nres_axis <- axis_wf %>% \n fit_resamples(resamples = splits, \n               metrics = metric_set(rmse, rsq))\n\nres_oblique <- oblique_wf %>% \n fit_resamples(resamples = splits, \n               metrics = metric_set(rmse, rsq))\n\n# Combine results into a tibble\nresults <- bind_rows(\n  collect_metrics(res_axis) %>% mutate(model = \"Axis-Based RF\"),\n  collect_metrics(res_oblique) %>% mutate(model = \"Oblique RF\")\n)\n\n# Print results\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n  .metric .estimator  mean     n std_err .config              model        \n  <chr>   <chr>      <dbl> <int>   <dbl> <chr>                <chr>        \n1 rmse    standard   1.52      5 0.130   Preprocessor1_Model1 Axis-Based RF\n2 rsq     standard   0.760     5 0.0458  Preprocessor1_Model1 Axis-Based RF\n3 rmse    standard   0.727     5 0.0512  Preprocessor1_Model1 Oblique RF   \n4 rsq     standard   0.948     5 0.00779 Preprocessor1_Model1 Oblique RF   \n```\n\n\n:::\n:::\n\n\n\n\n\n## Overview\n\n- Decision trees\n\n    + Growing trees\n    \n    + Leaf nodes\n\n- Random Forests\n\n    + Out-of-bag predictions\n    \n    + Variable importance\n\n---\n\n![](img/penguins.png){width=100%}\n\n:::footer\nData were collected and made available by [Dr. Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) and the Palmer Station, a member of the [Long Term Ecological Research Network](https://lternet.edu/).\n:::\n\n# Decision trees\n\n---\n\nDecision trees grow by recursively splitting data.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/penguin-fig-demo-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n---\n\nSplits should create groups with different outcomes.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n---\n\nSplitting continues until stopping criterion are met.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n---\n\nThe same splits, visualized as a tree\n\n![](img/rpart_plot_classif.png){fig-align=\"center\"}\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}